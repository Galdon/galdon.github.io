[{"title":"每天巩固Java知识(二) 值传递和引用传递","date":"2017-02-22T16:31:50.000Z","path":"2017/02/23/02-23-java-02/","text":"Java 中的值传递和引用传递算是一个老生常谈的问题了，并且这个问题一直活跃在各大公司的基础面试题当中，虽然遇到这种问题不会犯错，但对其原理还是有些模糊，这次特对这个问题做一个全面的整理。 基本类型和引用类型的不同基本类型在 《Thinking in Java》 一书中，基本类型有如下描述 Java采取与C和C++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。 由此可以看出，基本类型存于堆栈中，并且直接存储了它的值。 引用类型在创建一个对象时，对象的引用会存放在堆栈中，储存的是引用关系，而对象的值则存放在堆中，储存的是对象本身。 值传递和引用传递值传递一个方法在调用时，实参把值传给形参，形参进入方法后实际上是实参的值的一份拷贝，在这之后再对这个型参所做任何操作实际上只是对这份拷贝做操作，原有的值也就是实参的值不会发生任何变化。当参数是基本类型时，参数传递为值传递。 引用传递权威的说法是：Java 只有值传递，没有引用传递。实际上这里所说的引用传递依然是值传递，只不过这里的值是一个引用关系。具体来说，一个方法在调用时，实参所代表的引用传给形参，形参进入方法后实际上是一个地址，也就是形参和实参所代表的意思相同，都是一个地址，在这之后再对这个地址所找到的值进行操作均会影响到原有的实参所指的值。 当参数是对象类型时，参数传递依然是值传递，但这个值指的是一个引用。 一些特殊的类型String, Integer, Double 等 immutable 的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。 简单例子12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args)&#123; Test test = new Test(); //传递的是值 int a = 0; test.test1(a);//这里传递的参数a就是按值传递 System.out.println(a); //传递的是引用 MyObj obj = new MyObj(); test.test2(obj);//这里传递的参数obj就是引用传递 System.out.println(obj.b); &#125; public void test1(int a)&#123; a = a++; System.out.println(a); &#125; public void test2(MyObj obj)&#123; obj.b = 1; System.out.println(obj.b); &#125;&#125;class MyObj&#123; public int b = 0;&#125; 经典问题123456789101112131415public class Swap &#123; //数值交换函数 public static void swap(int a,int b)&#123; int temp=a; a=b; b=temp; &#125; public static void main(String[] args) &#123; int m=1,n=2; swap(m,n); System.out.println(\"m=\"+m+\",n=\"+n); &#125;&#125; 根据以上论述我们容易知道， Swap 这个方法所操作的两个数，实际上是 m 和 n 分别的副本，交换的是副本，原值并未交换。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://galdon.github.io/tags/笔记/"},{"name":"后端","slug":"后端","permalink":"https://galdon.github.io/tags/后端/"},{"name":"Java","slug":"Java","permalink":"https://galdon.github.io/tags/Java/"}]},{"title":"每天巩固Java知识(一) 上溯造型和下溯造型","date":"2017-02-21T17:57:27.000Z","path":"2017/02/22/02-22-java-01/","text":"在 《Thinking in Java》 一书中，有如下说法： 把将导出类看作是它的基类的过程成为向上转型(upcasting)。 其实此处提到的向上转型即上溯造型，反之为下溯造型。 上溯造型一个简单的例子：在一个需要传入基类对象作为方法参数的地方，我们以其导出类对象代替传入，编译器编译时就会上溯造型，将该参数的类型转换为其父类的类型，具体例子为如下代码： 12345678910111213141516171819202122class Shape &#123; public void draw() &#123; &#125;&#125;class Circle extends Shape &#123; @Override public void draw() &#123; System.out.println(\"Circle\"); &#125;; public void drawDouble() &#123; System.out.println(\"CircleCircle\"); &#125; &#125;class Square extends Shape &#123; @Override public void draw() &#123; System.out.println(\"Square\"); &#125; &#125; 根据 Java 的继承特性，该转换使得这个导出类的接口变得更“窄“，在此之后的代码中若出现调用该导出类(作为参数传入)特有的方法或属性时，因编译器已经将该对象类型转换为基类类型，并且基类不具备导出类中的特有方法和属性，这时编译不能通过，我们认为这个过程是安全的类型转换。 12345678910111213public class Test &#123; public static void main (String[] args) throws java.lang.Exception &#123; Circle circle = new Circle(); Shape shape = new Shape(); upCasting(circle); &#125; // 上溯造型示例 public static void upCasting(Shape shape) &#123; shape.drawDouble(); //编译时就会报错，安全的类型转换 shape.draw(); &#125;&#125; 同样，在 《Thinking in Java》 一书中还提到： 一个面向对象程序一定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放的关键。 这也就是我们为什么经常在面向对象编程中普遍使用上述例子的原因。我们当然可以将这个例子中的参数类型改为具体的某个导出类的类型，但是当我们需要实现一个几乎同样的方法，并且其参数为另一个导出类的时候，我们就只能再粘贴一份相同的代码，只将参数类型改为另一个导出类的类型，显然这是不合适的。 利用上溯造型的原理，我们只需像例子中那样，将参数类型定为基类的类型，这也就是我们上面提到的 将自己从必须知道确切类型中解放。 下溯造型下溯造型与上溯造型相反，它是一种强制类型转换。由于这种转换在程序的编译期无法被检测出来，所以运行时若不做限制则极有可能抛出 ClassCastException 异常，显然它是不安全的类型转换，我们在编写程序时应尽量避免。 12345678910111213public class Test &#123; public static void main (String[] args) throws java.lang.Exception &#123; Circle circle = new Circle(); Shape shape = new Shape(); downCasting(shape); &#125; // 下溯造型示例 public static void downCasting(Shape shape) &#123; Circle circle = (Circle) shape; //运行时异常：java.lang.ClassCastException，不安全的类型转换 circle.draw(); &#125;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"https://galdon.github.io/tags/笔记/"},{"name":"后端","slug":"后端","permalink":"https://galdon.github.io/tags/后端/"},{"name":"java","slug":"java","permalink":"https://galdon.github.io/tags/java/"}]},{"title":"CSS中的长度超出省略控制","date":"2017-02-16T16:33:17.000Z","path":"2017/02/17/02-17-css-ellipsis/","text":"为解决使 html 页面中 &lt;span&gt;、&lt;div&gt;、&lt;input&gt; 标签内容在有限宽度中溢出部分用省略号省略的问题。可使用 css 分别控制文本不换行、超出部分隐藏、隐藏部分省略号代替。 代码如下： 12345.test&#123; white-space:nowrap; //文本不换行 overflow:hidden; //文本超出隐藏 text-overflow:ellipsis; //超出部分省略号代替&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://galdon.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"https://galdon.github.io/tags/css/"},{"name":"笔记","slug":"笔记","permalink":"https://galdon.github.io/tags/笔记/"}]},{"title":"一个承载了美好愿望的开始","date":"2017-02-15T12:56:05.000Z","path":"2017/02/15/first-article/","text":"千里之行，始于足下。今天用 Hexo 搭了个人博客，开始写一些技术笔记、心得和随笔。希望2020年之前我能成功进入大公司。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://galdon.github.io/tags/随笔/"}]}]