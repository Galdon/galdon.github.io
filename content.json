[{"title":"每天巩固Java知识(一) 上溯造型和下溯造型","date":"2017-02-21T15:57:27.000Z","path":"2017/02/21/02-22-java-01/","text":"在 《Thinking in Java》 一书中，有如下说法： 把将导出类看作是它的基类的过程成为向上转型(upcasting)。 其实此处提到的向上转型即上溯造型，反之为下溯造型。 上溯造型一个简单的例子：在一个需要传入基类对象作为方法参数的地方，我们以其导出类对象代替传入，编译器编译时就会上溯造型，将该参数的类型转换为其父类的类型，具体例子为如下代码： 12345678910111213141516171819202122class Shape &#123; public void draw() &#123; &#125;&#125;class Circle extends Shape &#123; @Override public void draw() &#123; System.out.println(\"Circle\"); &#125;; public void drawDouble() &#123; System.out.println(\"CircleCircle\"); &#125; &#125;class Square extends Shape &#123; @Override public void draw() &#123; System.out.println(\"Square\"); &#125; &#125; 根据 Java 的继承特性，该转换使得这个导出类的接口变得更“窄“，在此之后的代码中若出现调用该导出类(作为参数传入)特有的方法或属性时，因编译器已经将该对象类型转换为基类类型，并且基类不具备导出类中的特有方法和属性，这时编译不能通过，我们认为这个过程是安全的类型转换。 12345678910111213public class Test &#123; public static void main (String[] args) throws java.lang.Exception &#123; Circle circle = new Circle(); Shape shape = new Shape(); upCasting(circle); &#125; // 上溯造型示例 public static void upCasting(Shape shape) &#123; shape.drawDouble(); //编译时就会报错，安全的类型转换 shape.draw(); &#125;&#125; 同样，在 《Thinking in Java》 一书中还提到： 一个面向对象程序一定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放的关键。 这也就是我们为什么经常在面向对象编程中普遍使用上述例子的原因。我们当然可以将这个例子中的参数类型改为具体的某个导出类的类型，但是当我们需要实现一个几乎同样的方法，并且其参数为另一个导出类的时候，我们就只能再粘贴一份相同的代码，只将参数类型改为另一个导出类的类型，显然这是不合适的。 利用上溯造型的原理，我们只需像例子中那样，将参数类型定为基类的类型，这也就是我们上面提到的 将自己从必须知道确切类型中解放。 下溯造型下溯造型与上溯造型相反，它是一种强制类型转换。由于这种转换在程序的编译期无法被检测出来，所以运行时若不做限制则极有可能抛出 ClassCastException 异常，显然它是不安全的类型转换，我们在编写程序时应尽量避免。 12345678910111213public class Test &#123; public static void main (String[] args) throws java.lang.Exception &#123; Circle circle = new Circle(); Shape shape = new Shape(); downCasting(shape); &#125; // 下溯造型示例 public static void downCasting(Shape shape) &#123; Circle circle = (Circle) shape; //运行时异常：java.lang.ClassCastException，不安全的类型转换 circle.draw(); &#125;&#125;","tags":[{"name":"后端","slug":"后端","permalink":"https://galdon.github.io/tags/后端/"},{"name":"java","slug":"java","permalink":"https://galdon.github.io/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"https://galdon.github.io/tags/笔记/"}]},{"title":"CSS中的长度超出省略控制","date":"2017-02-16T16:33:17.000Z","path":"2017/02/17/02-17-css-ellipsis/","text":"为解决使 html 页面中 &lt;span&gt;、&lt;div&gt;、&lt;input&gt; 标签内容在有限宽度中溢出部分用省略号省略的问题。可使用 css 分别控制文本不换行、超出部分隐藏、隐藏部分省略号代替。 代码如下： 12345.test&#123; white-space:nowrap; //文本不换行 overflow:hidden; //文本超出隐藏 text-overflow:ellipsis; //超出部分省略号代替&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"https://galdon.github.io/tags/笔记/"},{"name":"前端","slug":"前端","permalink":"https://galdon.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"https://galdon.github.io/tags/css/"}]},{"title":"一个承载了美好愿望的开始","date":"2017-02-15T12:56:05.000Z","path":"2017/02/15/first-article/","text":"千里之行，始于足下。今天用 Hexo 搭了个人博客，开始写一些技术笔记、心得和随笔。希望2020年之前我能成功进入大公司。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://galdon.github.io/tags/随笔/"}]}]